alloy:
  mounts:
    extra:
      - name: journal-logs
        mountPath: /var/log/journal
        readOnly: true
      - name: machine-id
        mountPath: /etc/machine-id
        readOnly: true
  configMap:
    content: |-
      // WRITE: Push to local K3s-Loki
      // -------------------------------------------------------------------------
      loki.write "local_loki" {
        endpoint {
          url = "http://loki.observability.svc.cluster.local:3100/loki/api/v1/push"
        }
      }

      // -------------------------------------------------------------------------
      // SOURCE: Systemd Journal
      // -------------------------------------------------------------------------
      loki.source.journal "systemd" {
        forward_to    = [loki.process.journal_pipeline.receiver]
        relabel_rules = loki.relabel.journal_relabel.rules
        labels        = {
          agent = "alloy",
          job   = "systemd-journal",
        }
      }

      loki.relabel "journal_relabel" {
        forward_to = []

        rule {
          source_labels = ["__journal__systemd_unit"]
          target_label  = "unit"
        }
        rule {
          source_labels = ["__journal_syslog_identifier"]
          target_label  = "syslog_identifier"
        }

        // Priority 1: Extract service from SYSLOG_IDENTIFIER
        rule {
          source_labels = ["__journal_syslog_identifier"]
          regex         = "(gitops-sync|reading-sync|system-metrics|volume-backup|proxy|tailscale-gate).*"
          target_label  = "service"
          replacement   = "$1"
        }

        // Priority 2: If service is still empty, extract from SYSTEMD_UNIT
        rule {
          source_labels = ["service", "__journal__systemd_unit"]
          regex         = ";(gitops-sync|reading-sync|system-metrics|volume-backup|proxy|tailscale-gate).*"
          target_label  = "service"
          replacement   = "$1"
        }
      }

      loki.process "journal_pipeline" {
        // Filter: Keep logs that match our specific services (either by unit or service label)
        stage.match {
          selector = `{unit!~"(gitops-sync|reading-sync|system-metrics|volume-backup|proxy|tailscale-gate).service", service!~"(gitops-sync|reading-sync|system-metrics|volume-backup|proxy|tailscale-gate)"}`
          action   = "drop"
        }

        // Pipeline for survived logs
        stage.json {
          expressions = {
            level   = "level",
            service = "service",
            msg     = "msg",
          }
        }

        stage.labels {
          values = {
            level   = null,
            service = null,
          }
        }

        forward_to = [loki.write.local_loki.receiver]
      }

controller:
  type: daemonset
  hostNetwork: false
  volumes:
    extra:
      - name: journal-logs
        hostPath:
          path: /var/log/journal
      - name: machine-id
        hostPath:
          path: /etc/machine-id